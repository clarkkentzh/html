<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>构造函数继承</title>
  </head>
  <body>
    <script type="text/javascript">
      function Father(name,age){
        this.name = name;
        this.age = age;
        this.colors = ["red","green","blue"];
      }
      Father.prototype.getName = function(){
        return this.name;
      }

      function Son(name,age,score){
        Father.call(this,name,age);//调用Father构造函数，this指one
        this.score = score;//添加新的属性
      }

    //  借用构造函数，让每个对象都拥有自己的属性，相互之间没有任何关系
    //  但是原型上的属性和方法，是没法拥有的。

      var one = new Son("zhaohong",24,100);
      console.log(one);
      console.log(one.name);  //zhaohong
      console.log(one.age);  //24
      console.log(one.score);  //100


      //修改一个对象的属性不会影响其他对象的属性

      one.colors.push("yellow");
      var two = new Son("zh",50,100);
      console.log(two);
      console.log(two.colors); //["red","green","blue"]




  //call方法
      var value = 0;
      var obj = {
        value: 100
      };

      function fun(){
        console.log(this);
        console.log(this.value);
      }

      fun();//0,调用的时候this指的是window
      fun.call(obj);//100,相当于将fun内部的额this变为obj

  //apply方法
      var values = 0;
      var objs = {
        values:100
      };
      function fun1(arg1,arg2){
        console.log(arg1,arg2);
        console.log(this.values);
      }
      fun1.apply(objs,[1,2]);

  //call和apply的不同之处在于传递参数的方式不同,call是一系列的参数，apply是参数数组


    </script>
  </body>
</html>
